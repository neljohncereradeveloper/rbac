---
description: Feature-based folder and module structure
alwaysApply: true
---

# Feature-Based Structure

Organize code by feature (bounded context), not by technical layer across the whole app.

## Folder Layout

Group by feature first, then by layer inside the feature:

```
src/
  features/
    <feature_name>/           # e.g. user_management, order_processing
      domain/
        models/               # pure domain models (no framework/DB)
        constants/            # constants per model (e.g. statuses, limits, defaults)
        exceptions/           # business/domain exceptions per model
        value_objects/
        repositories/         # interfaces only
      application/
        use_cases/
          <model_name>/        # e.g. role/, permission/, user-role/
        commands/
          <model_name>/        # e.g. role/, permission/, user-role/
      infrastructure/
        entities/             # persistence/ORM entities (DB-specific)
        repositories/         # implementations
        mappers/
      presentation/
        controllers/
          <model_name>/        # e.g. role/, permission/, user-role/
        dto/
          <model_name>/        # e.g. role/, permission/, user-role/
  core/                        # code used by 2+ features (no duplication)
    domain/
    application/
    infrastructure/
      decorators/              # shared decorators (validation, param extraction, etc.)
      ...
    utils/                     # reusable utilities for all features
```

## Application Layer Structure

Organize use cases and commands by model/aggregate. Each model has its own folder in `use_cases/` and `commands/`:

```
application/
  use_cases/
    role/                      # Role-related use cases
      create.use-case.ts
      update.use-case.ts
      archive.use-case.ts
      restore.use-case.ts
      get-by-id.use-case.ts
      get-paginated.use-case.ts
      index.ts
    permission/                # Permission-related use cases
      create.use-case.ts
      update.use-case.ts
      archive.use-case.ts
      restore.use-case.ts
      get-by-id.use-case.ts
      index.ts
    role-permission/           # Role-Permission relationship use cases
      assign-permissions.use-case.ts
      remove-permissions.use-case.ts
      index.ts
    user-role/                 # User-Role relationship use cases
      assign-roles.use-case.ts
      remove-roles.use-case.ts
      index.ts
    user-permission/           # User-Permission override use cases
      grant-permissions.use-case.ts
      deny-permissions.use-case.ts
      remove-overrides.use-case.ts
      index.ts
    index.ts                   # Export all use cases
  commands/
    role/                      # Role-related commands (interfaces/types only)
      create-role.command.ts
      update-role.command.ts
      index.ts
    permission/                # Permission-related commands (interfaces/types only)
      create-permission.command.ts
      update-permission.command.ts
      index.ts
    role-permission/           # Role-Permission commands (interfaces/types only)
      assign-permissions-to-role.command.ts
      index.ts
    user-role/                 # User-Role commands (interfaces/types only)
      assign-roles-to-user.command.ts
      index.ts
    user-permission/           # User-Permission commands (interfaces/types only)
      grant-permissions-to-user.command.ts
      deny-permissions-to-user.command.ts
      index.ts
    index.ts                   # Export all commands
```

- **Each model/aggregate has its own folder** in both `use_cases/` and `commands/`.
- **Group related operations** together (e.g., all role operations in `use_cases/role/`).
- **Use case file names exclude the model name** since they're already in a model-specific folder (e.g., `create.use-case.ts` in `role/`, not `create-role.use-case.ts`).
- **Command file names include the model name** for clarity when importing (e.g., `create-role.command.ts`).
- **Use kebab-case** for file names (e.g., `create.use-case.ts`, `assign-permissions-to-role.command.ts`).
- **Commands are TypeScript interfaces/types only** - no validation decorators (validation belongs in presentation layer DTOs).
- **Include index.ts** in each folder to export its contents, and a root index.ts to export all.

**Note:** Application layer uses **commands** (interfaces/types), while presentation layer uses **DTOs** (classes with validation decorators). Controllers map presentation DTOs to application commands before calling use cases.

## Presentation Layer Structure

Organize DTOs and controllers by model/aggregate, matching the application layer structure. Each model has its own folder in `dto/` and its own controller file in `controllers/`:

```
presentation/
  dto/
    role/                      # Role-related DTOs (classes with validation decorators)
      create-role.dto.ts
      update-role.dto.ts
      index.ts
    permission/                # Permission-related DTOs
      create-permission.dto.ts
      update-permission.dto.ts
      index.ts
    role-permission/           # Role-Permission DTOs
      assign-permissions-to-role.dto.ts
      remove-permissions-from-role.dto.ts
      index.ts
    user-role/                 # User-Role DTOs
      assign-roles-to-user.dto.ts
      remove-roles-from-user.dto.ts
      index.ts
    user-permission/           # User-Permission DTOs
      grant-permissions-to-user.dto.ts
      deny-permissions-to-user.dto.ts
      remove-permissions-from-user.dto.ts
      index.ts
    index.ts                   # Export all DTOs
  controllers/
    role/                      # Role controller
      role.controller.ts
      index.ts
    permission/                # Permission controller
      permission.controller.ts
      index.ts
    role-permission/           # Role-Permission controller
      role-permission.controller.ts
      index.ts
    user-role/                 # User-Role controller
      user-role.controller.ts
      index.ts
    user-permission/           # User-Permission controller
      user-permission.controller.ts
      index.ts
    index.ts                   # Export all controllers
```

- **Each model/aggregate has its own folder** in both `dto/` and `controllers/` (e.g., `dto/role/`, `controllers/role/`).
- **Each model/aggregate has its own controller file** in its model folder (e.g., `controllers/role/role.controller.ts`, `controllers/permission/permission.controller.ts`).
- **DTO file names include the model name** for clarity when importing (e.g., `create-role.dto.ts`, `assign-permissions-to-role.dto.ts`).
- **Controller file names follow the pattern** `<model-name>.controller.ts` (e.g., `role.controller.ts`, `role-permission.controller.ts`).
- **Use kebab-case** for file names (e.g., `create-role.dto.ts`, `role-permission.controller.ts`).
- **DTOs are classes with validation decorators** - use `class-validator` decorators like `@RequiredStringValidation`, `@IsEmail`, `@IsArray`, etc.
- **Controllers map presentation DTOs to application commands** before calling use cases.
- **Include index.ts** in each DTO and controller folder to export its contents, and root index.ts files to export all DTOs and controllers.

**Example Controller Pattern:**

```ts
@Controller("roles")
export class RoleController {
  constructor(
    private readonly createRoleUseCase: CreateRoleUseCase // ... other use cases
  ) {}

  @Post()
  @Version("1")
  @HttpCode(HttpStatus.CREATED)
  async create(
    @Body() presentationDto: CreateRoleDto,
    @Req() request: Request
  ): Promise<Role> {
    const requestInfo = createRequestInfo(request);
    // Map presentation DTO to application command
    const command: CreateRoleCommand = {
      name: presentationDto.name,
      description: presentationDto.description ?? null,
      permission_ids: presentationDto.permission_ids,
    };
    return this.createRoleUseCase.execute(command, requestInfo);
  }
}
```

- Controllers handle HTTP requests and responses.
- Extract `RequestInfo` from the request using `createRequestInfo(request)` for audit trails.
- Map presentation DTOs (with validation) to application commands (simple interfaces) before calling use cases.
- Use RESTful endpoints with versioning (`@Version('1')`).
- Return appropriate HTTP status codes (`@HttpCode(HttpStatus.CREATED)`, etc.).

## Feature-Specific Tokens and Database Models

Each feature should define its own token constants and database model constants in `domain/constants/` for feature-specific repositories and entities. Use `TOKENS_CORE` only for shared/core services (e.g., `TRANSACTIONPORT`, `ACTIVITYLOGS`).

**Example for RBAC feature:**

```ts
// features/rbac/domain/constants/tokens.constant.ts
export const RBAC_TOKENS = {
  ROLE: "RoleRepository",
  PERMISSION: "PermissionRepository",
  ROLE_PERMISSION: "RolePermissionRepository",
  USER_ROLE: "UserRoleRepository",
  USER_PERMISSION: "UserPermissionRepository",
} as const;

// features/rbac/domain/constants/database.constants.ts
export const RBAC_DATABASE_MODELS = {
  ROLES: "roles",
  PERMISSIONS: "permissions",
  ROLE_PERMISSIONS: "role_permissions",
  USER_ROLES: "user_roles",
  USER_PERMISSIONS: "user_permissions",
} as const;
```

- Feature-specific repositories use feature tokens (e.g., `RBAC_TOKENS.ROLE`).
- Feature-specific entities use feature database model constants (e.g., `RBAC_DATABASE_MODELS.ROLES`).
- Shared/core services use `TOKENS_CORE` (e.g., `TOKENS_CORE.TRANSACTIONPORT`, `TOKENS_CORE.ACTIVITYLOGS`).
- Export tokens and database models from `domain/constants/index.ts` alongside action constants.

## Use Case Pattern: Archive

Use this pattern for archive (soft-delete) use cases. Replace `Role` / `role` with your model name:

```ts
import { Inject, Injectable } from "@nestjs/common";
import { TOKENS_CORE } from "@/core/domain/constants";
import { ActivityLogRepository } from "@/core/domain/repositories";
import { ActivityLog } from "@/core/domain/models";
import { TransactionPort } from "@/core/domain/ports";
import { HTTP_STATUS } from "@/core/domain/constants";
import { RoleBusinessException } from "@/features/rbac/domain/exceptions";
import { RoleRepository } from "@/features/rbac/domain/repositories";
import {
  ROLE_ACTIONS,
  RBAC_TOKENS,
  RBAC_DATABASE_MODELS,
} from "@/features/rbac/domain/constants";
import { RequestInfo } from "@/core/utils/request-info.util";
import { getPHDateTime } from "@/core/utils/date.util";

@Injectable()
export class ArchiveRoleUseCase {
  constructor(
    @Inject(TOKENS_CORE.TRANSACTIONPORT)
    private readonly transactionHelper: TransactionPort,
    @Inject(RBAC_TOKENS.ROLE)
    private readonly roleRepository: RoleRepository,
    @Inject(TOKENS_CORE.ACTIVITYLOGS)
    private readonly activityLogRepository: ActivityLogRepository
  ) {}

  async execute(id: number, requestInfo?: RequestInfo): Promise<boolean> {
    return this.transactionHelper.executeTransaction(
      ROLE_ACTIONS.ARCHIVE,
      async (manager) => {
        // Validate existence
        const role = await this.roleRepository.findById(id, manager);
        if (!role) {
          throw new RoleBusinessException(
            `Role with ID ${id} not found.`,
            HTTP_STATUS.NOT_FOUND
          );
        }

        // Use domain method to archive (soft delete)
        role.archive(requestInfo?.user_name || "");

        // Update the entity
        const success = await this.roleRepository.update(id, role, manager);
        if (!success) {
          throw new RoleBusinessException(
            "Role archive failed",
            HTTP_STATUS.INTERNAL_SERVER_ERROR
          );
        }

        // Log the archive
        const log = ActivityLog.create({
          action: ROLE_ACTIONS.ARCHIVE,
          entity: RBAC_DATABASE_MODELS.ROLES,
          details: JSON.stringify({
            id,
            name: role.name,
            explanation: `Role with ID : ${id} archived by USER : ${
              requestInfo?.user_name || ""
            }`,
            archived_by: requestInfo?.user_name || "",
            archived_at: getPHDateTime(role.deleted_at || new Date()),
          }),
          request_info: requestInfo || { user_name: "" },
        });
        await this.activityLogRepository.create(log, manager);

        return true;
      }
    );
  }
}
```

- Use `@Injectable()` and `@Inject()` for dependency injection.
- **Feature-specific repositories** use feature tokens (e.g., `RBAC_TOKENS.ROLE`).
- **Feature-specific entities** use feature database model constants (e.g., `RBAC_DATABASE_MODELS.ROLES`).
- **Shared/core services** use `TOKENS_CORE` (e.g., `TOKENS_CORE.TRANSACTIONPORT`, `TOKENS_CORE.ACTIVITYLOGS`).
- Wrap operations in `transactionHelper.executeTransaction()` for atomicity.
- Validate entity existence before archiving.
- Use domain model's `archive()` method (not direct repository update).
- Log the action using `ActivityLog.create()` with action constant and entity constant.
- Throw domain exceptions (`<Model>BusinessException`) with appropriate HTTP status codes:
  - `HTTP_STATUS.NOT_FOUND` if entity doesn't exist
  - `HTTP_STATUS.INTERNAL_SERVER_ERROR` if update fails
- Pass `RequestInfo` for audit trail (user_name, ip_address, etc.).

## Use Case Pattern: Create

Use this pattern for create use cases. Replace `Role` / `role` with your model name:

```ts
import { Inject, Injectable } from "@nestjs/common";
import { TOKENS_CORE } from "@/core/domain/constants";
import { ActivityLogRepository } from "@/core/domain/repositories";
import { RequestInfo } from "@/core/utils/request-info.util";
import { getPHDateTime } from "@/core/utils/date.util";
import { ActivityLog } from "@/core/domain/models";
import { TransactionPort } from "@/core/domain/ports";
import { HTTP_STATUS } from "@/core/domain/constants";
import { RoleBusinessException } from "@/features/rbac/domain/exceptions";
import { Role } from "@/features/rbac/domain/models";
import { RoleRepository } from "@/features/rbac/domain/repositories";
import {
  ROLE_ACTIONS,
  RBAC_TOKENS,
  RBAC_DATABASE_MODELS,
} from "@/features/rbac/domain/constants";
import { CreateRoleCommand } from "../commands/role/create-role.command";

@Injectable()
export class CreateRoleUseCase {
  constructor(
    @Inject(TOKENS_CORE.TRANSACTIONPORT)
    private readonly transactionHelper: TransactionPort,
    @Inject(RBAC_TOKENS.ROLE)
    private readonly roleRepository: RoleRepository,
    @Inject(TOKENS_CORE.ACTIVITYLOGS)
    private readonly activityLogRepository: ActivityLogRepository
  ) {}

  async execute(
    command: CreateRoleCommand,
    requestInfo?: RequestInfo
  ): Promise<Role> {
    return this.transactionHelper.executeTransaction(
      ROLE_ACTIONS.CREATE,
      async (manager) => {
        // Create domain model (validates automatically)
        const new_role = Role.create({
          name: command.name,
          description: command.description ?? null,
          created_by: requestInfo?.user_name || null,
        });

        // Persist the entity
        const created_role = await this.roleRepository.create(
          new_role,
          manager,
          command.permission_ids
        );

        if (!created_role) {
          throw new RoleBusinessException(
            "Role creation failed",
            HTTP_STATUS.INTERNAL_SERVER_ERROR
          );
        }

        // Log the creation
        const log = ActivityLog.create({
          action: ROLE_ACTIONS.CREATE,
          entity: RBAC_DATABASE_MODELS.ROLES,
          details: JSON.stringify({
            id: created_role.id,
            name: created_role.name,
            description: created_role.description,
            created_by: requestInfo?.user_name || "",
            created_at: getPHDateTime(created_role.created_at),
          }),
          request_info: requestInfo || { user_name: "" },
        });
        await this.activityLogRepository.create(log, manager);

        return created_role;
      }
    );
  }
}
```

- Use `@Injectable()` and `@Inject()` for dependency injection.
- **Feature-specific repositories** use feature tokens (e.g., `RBAC_TOKENS.ROLE`).
- **Shared/core services** use `TOKENS_CORE` (e.g., `TOKENS_CORE.TRANSACTIONPORT`, `TOKENS_CORE.ACTIVITYLOGS`).
- Wrap operations in `transactionHelper.executeTransaction()` for atomicity.
- Use domain model's `create()` static factory method (validates automatically).
- Persist via repository `create()` method.
- Log the action using `ActivityLog.create()` with action constant and entity constant.
- Throw domain exceptions (`<Model>BusinessException`) with appropriate HTTP status codes:
  - `HTTP_STATUS.INTERNAL_SERVER_ERROR` if creation fails
- Pass `RequestInfo` for audit trail (user_name, ip_address, etc.).
- Include optional fields like `permission_ids` in command if creating with relationships.

## Use Case Pattern: Restore

Use this pattern for restore use cases. Replace `Role` / `role` with your model name:

```ts
import { Inject, Injectable } from "@nestjs/common";
import { TOKENS_CORE } from "@/core/domain/constants";
import { ActivityLogRepository } from "@/core/domain/repositories";
import { RequestInfo } from "@/core/utils/request-info.util";
import { getPHDateTime } from "@/core/utils/date.util";
import { ActivityLog } from "@/core/domain/models";
import { TransactionPort } from "@/core/domain/ports";
import { HTTP_STATUS } from "@/core/domain/constants";
import { RoleBusinessException } from "@/features/rbac/domain/exceptions";
import { RoleRepository } from "@/features/rbac/domain/repositories";
import {
  ROLE_ACTIONS,
  RBAC_TOKENS,
  RBAC_DATABASE_MODELS,
} from "@/features/rbac/domain/constants";

@Injectable()
export class RestoreRoleUseCase {
  constructor(
    @Inject(TOKENS_CORE.TRANSACTIONPORT)
    private readonly transactionHelper: TransactionPort,
    @Inject(RBAC_TOKENS.ROLE)
    private readonly roleRepository: RoleRepository,
    @Inject(TOKENS_CORE.ACTIVITYLOGS)
    private readonly activityLogRepository: ActivityLogRepository
  ) {}

  async execute(id: number, requestInfo?: RequestInfo): Promise<boolean> {
    return this.transactionHelper.executeTransaction(
      ROLE_ACTIONS.RESTORE,
      async (manager) => {
        // Validate existence
        const role = await this.roleRepository.findById(id, manager);
        if (!role) {
          throw new RoleBusinessException(
            `Role with ID ${id} not found.`,
            HTTP_STATUS.NOT_FOUND
          );
        }

        // Use domain method to restore
        role.restore();

        // Update the entity
        const success = await this.roleRepository.update(id, role, manager);
        if (!success) {
          throw new RoleBusinessException(
            "Role restore failed",
            HTTP_STATUS.INTERNAL_SERVER_ERROR
          );
        }

        // Log the restore
        const log = ActivityLog.create({
          action: ROLE_ACTIONS.RESTORE,
          entity: RBAC_DATABASE_MODELS.ROLES,
          details: JSON.stringify({
            id,
            name: role.name,
            explanation: `Role with ID : ${id} restored by USER : ${
              requestInfo?.user_name || ""
            }`,
            restored_by: requestInfo?.user_name || "",
            restored_at: getPHDateTime(new Date()),
          }),
          request_info: requestInfo || { user_name: "" },
        });
        await this.activityLogRepository.create(log, manager);

        return true;
      }
    );
  }
}
```

- Use `@Injectable()` and `@Inject()` for dependency injection.
- **Feature-specific repositories** use feature tokens (e.g., `RBAC_TOKENS.ROLE`).
- **Feature-specific entities** use feature database model constants (e.g., `RBAC_DATABASE_MODELS.ROLES`).
- **Shared/core services** use `TOKENS_CORE` (e.g., `TOKENS_CORE.TRANSACTIONPORT`, `TOKENS_CORE.ACTIVITYLOGS`).
- Wrap operations in `transactionHelper.executeTransaction()` for atomicity.
- Validate entity existence before restoring.
- Use domain model's `restore()` method (not direct repository update).
- Log the action using `ActivityLog.create()` with action constant and entity constant.
- Throw domain exceptions (`<Model>BusinessException`) with appropriate HTTP status codes:
  - `HTTP_STATUS.NOT_FOUND` if entity doesn't exist
  - `HTTP_STATUS.INTERNAL_SERVER_ERROR` if update fails
- Pass `RequestInfo` for audit trail (user_name, ip_address, etc.).

## Use Case Pattern: Combobox

Use this pattern for combobox use cases. Replace `Role` / `role` with your model name:

```ts
import { Inject, Injectable } from "@nestjs/common";
import { TOKENS_CORE } from "@/core/domain/constants";
import { TransactionPort } from "@/core/domain/ports";
import { RoleRepository } from "@/features/rbac/domain/repositories";
import { ROLE_ACTIONS, RBAC_TOKENS } from "@/features/rbac/domain/constants";

@Injectable()
export class ComboboxRoleUseCase {
  constructor(
    @Inject(RBAC_TOKENS.ROLE)
    private readonly roleRepository: RoleRepository,
    @Inject(TOKENS_CORE.TRANSACTIONPORT)
    private readonly transactionHelper: TransactionPort
  ) {}

  async execute(): Promise<{ value: string; label: string }[]> {
    return this.transactionHelper.executeTransaction(
      ROLE_ACTIONS.COMBOBOX,
      async (manager) => {
        const roles = await this.roleRepository.combobox(manager);
        return roles.map((role: { name: string }) => ({
          value: role.name || "",
          label: role.name
            ? role.name.charAt(0).toUpperCase() +
              role.name.slice(1).toLowerCase()
            : "",
        }));
      }
    );
  }
}
```

- Use `@Injectable()` and `@Inject()` for dependency injection.
- **Feature-specific repositories** use feature tokens (e.g., `RBAC_TOKENS.ROLE`).
- **Shared/core services** use `TOKENS_CORE` (e.g., `TOKENS_CORE.TRANSACTIONPORT`).
- Wrap operations in `transactionHelper.executeTransaction()` for atomicity.
- Call repository `combobox()` method to get list of entities.
- Map results to `{ value, label }` format for dropdown/select components.
- Format labels (e.g., capitalize first letter) as needed for display.
- No validation needed - combobox typically returns all active records.

## Use Case Pattern: Paginated List

Use this pattern for paginated list use cases. Replace `Role` / `role` with your model name:

```ts
import { Injectable, Inject } from "@nestjs/common";
import { TOKENS_CORE } from "@/core/domain/constants";
import { TransactionPort } from "@/core/domain/ports";
import { RoleRepository } from "@/features/rbac/domain/repositories";
import { ROLE_ACTIONS } from "@/features/rbac/domain/constants";
import { PaginatedResult } from "@/core/utils/pagination.util";
import { Role } from "@/features/rbac/domain/models";

@Injectable()
export class PaginatedListRoleUseCase {
  constructor(
    @Inject(TOKENS_CORE.ROLE)
    private readonly roleRepository: RoleRepository,
    @Inject(TOKENS_CORE.TRANSACTIONPORT)
    private readonly transactionHelper: TransactionPort
  ) {}

  async execute(
    term: string,
    page: number,
    limit: number,
    is_archived: boolean
  ): Promise<PaginatedResult<Role>> {
    return this.transactionHelper.executeTransaction(
      ROLE_ACTIONS.PAGINATED_LIST,
      async (manager) => {
        const roles = await this.roleRepository.findPaginatedList(
          term,
          page,
          limit,
          is_archived,
          manager
        );
        return roles;
      }
    );
  }
}
```

- Use `@Injectable()` and `@Inject()` for dependency injection.
- **Feature-specific repositories** use feature tokens (e.g., `RBAC_TOKENS.ROLE`).
- **Shared/core services** use `TOKENS_CORE` (e.g., `TOKENS_CORE.TRANSACTIONPORT`).
- Wrap operations in `transactionHelper.executeTransaction()` for atomicity.
- Call repository `findPaginatedList()` method with search term, pagination params, and archive filter.
- Returns `PaginatedResult<Model>` with `data` array and `meta` pagination information.
- No validation needed - repository handles query logic.
- Accepts `term` for search/filter, `page`/`limit` for pagination, `is_archived` to filter archived records.

## Use Case Pattern: Update

Use this pattern for update use cases. Replace `Role` / `role` with your model name:

```ts
import { Inject, Injectable } from "@nestjs/common";
import { TOKENS_CORE } from "@/core/domain/constants";
import { ActivityLogRepository } from "@/core/domain/repositories";
import { RequestInfo } from "@/core/utils/request-info.util";
import { getPHDateTime } from "@/core/utils/date.util";
import { ActivityLog } from "@/core/domain/models";
import { TransactionPort } from "@/core/domain/ports";
import { HTTP_STATUS } from "@/core/domain/constants";
import { RoleBusinessException } from "@/features/rbac/domain/exceptions";
import { Role } from "@/features/rbac/domain/models";
import { RoleRepository } from "@/features/rbac/domain/repositories";
import {
  ROLE_ACTIONS,
  RBAC_TOKENS,
  RBAC_DATABASE_MODELS,
} from "@/features/rbac/domain/constants";
import { UpdateRoleCommand } from "../commands/role/update-role.command";
import {
  getChangedFields,
  extractEntityState,
  FieldExtractorConfig,
} from "@/core/utils/change-tracking.util";

@Injectable()
export class UpdateRoleUseCase {
  constructor(
    @Inject(TOKENS_CORE.TRANSACTIONPORT)
    private readonly transactionHelper: TransactionPort,
    @Inject(RBAC_TOKENS.ROLE)
    private readonly roleRepository: RoleRepository,
    @Inject(TOKENS_CORE.ACTIVITYLOGS)
    private readonly activityLogRepository: ActivityLogRepository
  ) {}

  async execute(
    id: number,
    command: UpdateRoleCommand,
    requestInfo?: RequestInfo
  ): Promise<Role | null> {
    return this.transactionHelper.executeTransaction(
      ROLE_ACTIONS.UPDATE,
      async (manager) => {
        // Validate role existence
        const role = await this.roleRepository.findById(id, manager);
        if (!role) {
          throw new RoleBusinessException(
            "Role not found",
            HTTP_STATUS.NOT_FOUND
          );
        }

        // Define fields to track for change logging
        const tracking_config: FieldExtractorConfig[] = [
          { field: "name" },
          { field: "description" },
          {
            field: "updated_at",
            transform: (val) => (val ? getPHDateTime(val) : null),
          },
          { field: "updated_by" },
        ];

        // Capture before state for logging
        const before_state = extractEntityState(role, tracking_config);

        // Use domain model method to update (encapsulates business logic and validation)
        role.update({
          name: command.name,
          description: command.description ?? null,
          updated_by: requestInfo?.user_name || null,
        });

        // Update the role in the database
        const success = await this.roleRepository.update(id, role, manager);
        if (!success) {
          throw new RoleBusinessException(
            "Role update failed",
            HTTP_STATUS.INTERNAL_SERVER_ERROR
          );
        }

        // Retrieve the updated role
        const updated_result = await this.roleRepository.findById(id, manager);

        // Capture after state for logging
        const after_state = extractEntityState(updated_result, tracking_config);

        // Get only the changed fields with old and new states
        const changed_fields = getChangedFields(before_state, after_state);

        // Log the update with only changed fields (old state and new state)
        const log = ActivityLog.create({
          action: ROLE_ACTIONS.UPDATE,
          entity: RBAC_DATABASE_MODELS.ROLES,
          details: JSON.stringify({
            id: updated_result?.id,
            changed_fields: changed_fields,
            updated_by: requestInfo?.user_name || "",
            updated_at: getPHDateTime(updated_result?.updated_at || new Date()),
          }),
          request_info: requestInfo || { user_name: "" },
        });
        await this.activityLogRepository.create(log, manager);

        return updated_result;
      }
    );
  }
}
```

- Use `@Injectable()` and `@Inject()` for dependency injection.
- **Feature-specific repositories** use feature tokens (e.g., `RBAC_TOKENS.ROLE`).
- **Feature-specific entities** use feature database model constants (e.g., `RBAC_DATABASE_MODELS.ROLES`).
- **Shared/core services** use `TOKENS_CORE` (e.g., `TOKENS_CORE.TRANSACTIONPORT`, `TOKENS_CORE.ACTIVITYLOGS`).
- Wrap operations in `transactionHelper.executeTransaction()` for atomicity.
- Validate entity existence before updating using `findById()`.
- Use domain model's `update()` method (validates automatically and checks if archived).
- Capture before and after states using `extractEntityState()` with field configuration.
- Track only changed fields using `getChangedFields()` for efficient logging.
- Log the action using `ActivityLog.create()` with changed fields in details.
- Throw domain exceptions (`<Model>BusinessException`) with appropriate HTTP status codes:
  - `HTTP_STATUS.NOT_FOUND` if entity doesn't exist
  - `HTTP_STATUS.INTERNAL_SERVER_ERROR` if update fails
- Pass `RequestInfo` for audit trail (user_name, ip_address, etc.).
- Return the updated entity after successful update.

## Repository interface (default)

Use this as the default shape for repository interfaces in `domain/repositories/`. Replace the aggregate/model name and adjust methods as needed; keep `context: Context` on all methods.

```ts
import { PaginatedResult } from "@/core/utils/pagination.util";
import { Role } from "../models/role.model";

export interface RoleRepository<Context = unknown> {
  /** Create a role. Optionally link permissions via permission_ids. */
  create(
    role: Role,
    context: Context,
    permission_ids?: number[]
  ): Promise<Role>;
  update(id: number, dto: Partial<Role>, context: Context): Promise<boolean>;
  findById(id: number, context: Context): Promise<Role | null>;
  findPaginatedList(
    term: string,
    page: number,
    limit: number,
    is_archived: boolean,
    context: Context
  ): Promise<PaginatedResult<Role>>;
  findByName(name: string, context: Context): Promise<Role | null>;
  combobox(context: Context): Promise<Role[]>;
}
```

- `Context` is a generic (default `unknown`) passed through for tenant, user, or request-scoped data.
- Use `PaginatedResult<Model>` for list responses with total count and items.
- Omit or rename methods (e.g. `findByName`) per aggregate; keep `create`, `update`, `findById`, `findPaginatedList`, and `combobox` as the baseline.

## Domain model (example)

Put pure domain models in `domain/models/`. Use the following pattern: **properties** (id, business fields, then audit fields in standard order), **constructor**, **static create()**, **update()**, **archive()**, **restore()**, **validate()**. Replace `Role` / `role` and field names (e.g. `name`, `description`) with your aggregate.

```ts
import { HTTP_STATUS } from "@/core/domain/constants";
import { getPHDateTime } from "@/core/utils/date.util";
import { RoleBusinessException } from "../exceptions";

export class Role {
  id?: number;
  name: string;
  description: string | null;
  deleted_by: string | null;
  deleted_at: Date | null;
  created_by: string | null;
  created_at: Date;
  updated_by: string | null;
  updated_at: Date;

  constructor(dto: {
    id?: number;
    name: string;
    description?: string | null;
    deleted_by?: string | null;
    deleted_at?: Date | null;
    created_by?: string | null;
    created_at?: Date; // Optional - auto-generated by TypeORM @CreateDateColumn()
    updated_by?: string | null;
    updated_at?: Date; // Optional - auto-generated by TypeORM @UpdateDateColumn()
  }) {
    this.id = dto.id;
    this.name = dto.name;
    this.description = dto.description ?? null;
    this.deleted_by = dto.deleted_by ?? null;
    this.deleted_at = dto.deleted_at ?? null;
    this.created_by = dto.created_by ?? null;
    this.created_at = dto.created_at ?? getPHDateTime();
    this.updated_by = dto.updated_by ?? null;
    this.updated_at = dto.updated_at ?? getPHDateTime();
  }

  /** Static factory: create and validate. */
  static create(params: {
    name: string;
    description?: string | null;
    created_by?: string | null;
  }): Role {
    const role = new Role({
      name: params.name,
      description: params.description ?? null,
      created_by: params.created_by ?? null,
    });
    role.validate();
    return role;
  }

  /** Update details; validate new state before applying. */
  update(dto: {
    name: string;
    description?: string | null;
    updated_by?: string | null;
  }): void {
    if (this.deleted_at) {
      throw new RoleBusinessException(
        "Role is archived and cannot be updated",
        HTTP_STATUS.CONFLICT
      );
    }
    const tempRole = new Role({
      id: this.id,
      name: dto.name,
      description: dto.description ?? this.description,
      created_at: this.created_at,
      updated_at: this.updated_at,
    });
    tempRole.validate();
    this.name = dto.name;
    this.description = dto.description ?? this.description;
    this.updated_by = dto.updated_by ?? null;
  }

  /** Soft-delete. */
  archive(deleted_by: string): void {
    if (this.deleted_at) {
      throw new RoleBusinessException(
        "Role is already archived.",
        HTTP_STATUS.CONFLICT
      );
    }
    this.deleted_at = getPHDateTime();
    this.deleted_by = deleted_by;
  }

  /** Restore from archive. */
  restore(): void {
    if (!this.deleted_at) {
      throw new RoleBusinessException(
        `Role with ID ${this.id} is not archived.`,
        HTTP_STATUS.CONFLICT
      );
    }
    this.deleted_at = null;
    this.deleted_by = null;
  }

  /** Enforce business rules. */
  validate(): void {
    if (!this.name || this.name.trim().length === 0) {
      throw new RoleBusinessException(
        "Role name is required and cannot be empty.",
        HTTP_STATUS.BAD_REQUEST
      );
    }
    if (this.name.length > 255) {
      throw new RoleBusinessException(
        "Role name must not exceed 255 characters.",
        HTTP_STATUS.BAD_REQUEST
      );
    }
    if (this.name.trim().length < 2) {
      throw new RoleBusinessException(
        "Role name must be at least 2 characters long.",
        HTTP_STATUS.BAD_REQUEST
      );
    }
    if (this.description !== null && this.description !== undefined) {
      if (this.description.length > 500) {
        throw new RoleBusinessException(
          "Role description must not exceed 500 characters.",
          HTTP_STATUS.BAD_REQUEST
        );
      }
    }
  }
}
```

- **Properties:** id (optional), business fields, then audit fields in order: `deleted_by`, `deleted_at`, `created_by`, `created_at`, `updated_by`, `updated_at`.
- **Constructor:** Accept a DTO; use `?? null` for nullable audit fields; use `getPHDateTime()` (or equivalent) for `created_at` / `updated_at` when not provided.
- **create():** Static factory; build instance, call `validate()`, return.
- **update():** Reject if archived; validate via a temporary instance; then apply changes; do not set `updated_at` (ORM manages it).
- **archive():** Set `deleted_at` and `deleted_by`; throw if already archived.
- **restore():** Clear `deleted_at` and `deleted_by`; throw if not archived.
- **validate():** Throw `<Model>BusinessException` for rule violations (required, length, etc.).

## Constants: LOG ACTIONS (per model)

Define LOG ACTIONS for each model in `domain/constants/`, aligned with that model’s repository. Use as the default pattern (adjust keys to match repo methods):

```ts
export const ROLE_ACTIONS = {
  CREATE: "CREATE_ROLE",
  CREATE_WITH_PERMISSIONS: "CREATE_ROLE_WITH_PERMISSIONS",
  UPDATE: "UPDATE_ROLE",
  ARCHIVE: "ARCHIVE_ROLE",
  RESTORE: "RESTORE_ROLE",
  PAGINATED_LIST: "PAGINATED_LIST_ROLE",
  BY_NAME: "BY_NAME_ROLE",
  COMBOBOX: "COMBOBOX_ROLE",
  ASSIGN_PERMISSIONS: "ASSIGN_PERMISSIONS_TO_ROLE",
  REMOVE_PERMISSIONS: "REMOVE_PERMISSIONS_FROM_ROLE",
} as const;
```

- Name: `<MODEL>_ACTIONS` (e.g. `ROLE_ACTIONS`, `USER_ACTIONS`). Values: `'<ACTION>_<MODEL>'`.
- Include one entry per repository operation you log (create, update, archive, restore, findPaginatedList, findByName, combobox, etc.). Add or remove actions per model.

## Domain exceptions (per model)

Define a business/domain exception for each model in `domain/exceptions/`. Extend `DomainException` from core and use `HTTP_STATUS` from shared constants. Use as the default pattern:

```ts
import { HTTP_STATUS } from "@/core/domain/constants";
import { DomainException } from "@/core/domain/exceptions/domain.exception";

/**
 * Thrown when role data violates domain invariants or business rules
 */
export class RoleBusinessException extends DomainException {
  constructor(message: string, status_code: number = HTTP_STATUS.BAD_REQUEST) {
    super(message, "ROLE_BUSINESS_EXCEPTION", status_code);
    this.name = "RoleBusinessException";
  }
}
```

- Name: `<Model>BusinessException` (e.g. `RoleBusinessException`, `UserBusinessException`). Code: `'<MODEL>_BUSINESS_EXCEPTION'`.
- One exception class per model; throw when domain invariants or business rules are violated. Domain may depend on `@/core` (e.g. `DomainException`) and `@/core/domain/constants` (e.g. `HTTP_STATUS`) for exceptions only.

## Standard audit fields (entities)

Every **entity** in `infrastructure/entities/` (per feature or in core) must include the following six audit fields in this **exact order**:

1. `deleted_by` – User who deleted the record
2. `deleted_at` – Timestamp when the record was soft-deleted
3. `created_by` – User who created the record
4. `created_at` – Timestamp when the record was created
5. `updated_by` – User who last updated the record
6. `updated_at` – Timestamp when the record was last updated

**Nullability**

- **Nullable** (can be `null`): `deleted_by`, `deleted_at`, `created_by`, `updated_by`
  - `deleted_by: string | null` – Only set when a record is soft-deleted
  - `deleted_at: Date | null` – Only set when a record is soft-deleted
  - `created_by: string | null` – May be unset for system-generated records, bulk operations, or migrations
  - `updated_by: string | null` – May be unset if the record has not been updated yet, or for system operations
- **Non-nullable** (cannot be `null`): `created_at`, `updated_at`
  - `created_at: Date` – Always set by the ORM (e.g. `@CreateDateColumn()`) when a record is created
  - `updated_at: Date` – Always set by the ORM (e.g. `@UpdateDateColumn()`) when a record is created or updated

**TypeORM decorators**

Use the following TypeORM decorators for audit fields (replace `[entity name]` with the entity name, e.g. barangay, user):

```ts
// User fields (nullable)
@Column({
  type: 'varchar',
  length: 255,
  comment: 'User who deleted the [entity name]',
  nullable: true,
})
deleted_by: string | null;

@Column({
  type: 'varchar',
  length: 255,
  comment: 'User who created the [entity name]',
  nullable: true,
})
created_by: string | null;

@Column({
  type: 'varchar',
  length: 255,
  comment: 'User who last updated the [entity name]',
  nullable: true,
})
updated_by: string | null;

// Timestamp fields
@DeleteDateColumn({ nullable: true })
@Index()
deleted_at: Date | null; // For soft delete

@CreateDateColumn()
created_at: Date;

@UpdateDateColumn()
updated_at: Date;
```

- Declare these fields in every persistence/ORM entity. Use the same names, order, nullability, and decorators so mappers and queries stay consistent across models.

## Rules

- One folder per feature; name folders in snake_case (e.g. `user_management`, `order_processing`).
- **Domain is independent.** The domain layer must have no dependencies on application, infrastructure, or external libraries. Domain contains only models, constants, exceptions, value objects, repository interfaces, and events. Domain may depend on `@/core` (e.g. `DomainException`) and `@/core/domain/constants` (e.g. `HTTP_STATUS`) for exceptions only.
- **Constants for each model live in `domain/constants/`.** Put model-specific constants (e.g. status codes, validation limits, default values) in the feature’s domain—one file per model (e.g. `barangay-constants.ts`) or grouped under constants. Shared constants used by more than one feature go in `core/domain/constants/`.
- **Use cases and commands are organized by model.** Each model/aggregate has its own folder in `application/use_cases/` and `application/commands/`. Group related operations together (e.g., all role operations in `use_cases/role/`, all role commands in `commands/role/`). Commands are simple TypeScript interfaces/types without validation decorators - validation belongs in presentation layer DTOs.
- **Dependencies live in infrastructure.** All framework, database, ORM, and external-service dependencies belong in the infrastructure layer. Domain models are mapped to infrastructure entities (e.g. ORM/DB entities) via mappers.
- **If it’s used in more than one feature, it belongs in `core/`.** Do not duplicate shared logic across features—extract to core and import from there.
- **Reusable utilities for all features live in `core/utils/`.** Put cross-feature helpers (formatting, validation, date/time, string helpers, etc.) in `core/utils/`. Feature-specific utilities stay in the feature; only shared ones go in core.
- **Shared decorators live in `core/infrastructure/decorators/`.** Put decorators used by more than one feature (validation, param extraction, etc.) in `core/infrastructure/decorators/`. Feature-specific decorators stay in the feature’s infrastructure or presentation layer.
- Keep feature folders self-contained. Only feature-specific code stays in a feature; reused code lives in `core/`.
- Prefer importing from the same feature. Cross-feature or shared use: import from `core/`.
- Each feature can expose a single module (e.g. `UserManagementModule`) that wires domain, application, and infrastructure for that feature.
- Do not create top-level folders like `controllers/`, `services/`, `repositories/` that mix all features.
