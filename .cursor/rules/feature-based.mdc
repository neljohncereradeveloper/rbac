---
description: Feature-based folder and module structure
alwaysApply: true
---

# Feature-Based Structure

Organize code by feature (bounded context), not by technical layer across the whole app.

## Folder Layout

Group by feature first, then by layer inside the feature:

```
src/
  features/
    <feature_name>/           # e.g. user_management, order_processing
      domain/
        models/               # pure domain models (no framework/DB)
        constants/            # constants per model (e.g. statuses, limits, defaults)
        exceptions/           # business/domain exceptions per model
        value_objects/
        repositories/         # interfaces only
      application/
        use_cases/
        dto/
      infrastructure/
        entities/             # persistence/ORM entities (DB-specific)
        repositories/         # implementations
        mappers/
      presentation/
        controllers/
        dto/
  core/                        # code used by 2+ features (no duplication)
    domain/
    application/
    infrastructure/
      decorators/              # shared decorators (validation, param extraction, etc.)
      ...
    utils/                     # reusable utilities for all features
```

## Repository interface (default)

Use this as the default shape for repository interfaces in `domain/repositories/`. Replace the aggregate/model name and adjust methods as needed; keep `context: Context` on all methods.

```ts
import { PaginatedResult } from "@shared/interfaces";
import { Barangay } from "../models/barangay.model";

export interface BarangayRepository<Context = unknown> {
  create(barangay: Barangay, context: Context): Promise<Barangay>;
  update(
    id: number,
    dto: Partial<Barangay>,
    context: Context
  ): Promise<boolean>;
  findById(id: number, context: Context): Promise<Barangay | null>;
  findPaginatedList(
    term: string,
    page: number,
    limit: number,
    is_archived: boolean,
    context: Context
  ): Promise<PaginatedResult<Barangay>>;
  findByDescription(desc1: string, context: Context): Promise<Barangay | null>;
  combobox(context: Context): Promise<Barangay[]>;
}
```

- `Context` is a generic (default `unknown`) passed through for tenant, user, or request-scoped data.
- Use `PaginatedResult<Model>` for list responses with total count and items.
- Omit or rename methods (e.g. `findByDescription`) per aggregate; keep `create`, `update`, `findById`, `findPaginatedList`, and `combobox` as the baseline.

## Domain model (example)

Put pure domain models in `domain/models/`. Use the following pattern: **properties** (id, business fields, then audit fields in standard order), **constructor**, **static create()**, **update()**, **archive()**, **restore()**, **validate()**. Replace `Barangay` / `barangay` and field names (e.g. `desc1`) with your aggregate.

```ts
import { HTTP_STATUS } from "@core/domain/constants";
import { getPHDateTime } from "@core/utils";
import { BarangayBusinessException } from "@features/201-files/domain/exceptions";

export class Barangay {
  id?: number;
  desc1: string;
  deleted_by: string | null;
  deleted_at: Date | null;
  created_by: string | null;
  created_at: Date;
  updated_by: string | null;
  updated_at: Date;

  constructor(dto: {
    id?: number;
    desc1: string;
    deleted_by?: string | null;
    deleted_at?: Date | null;
    created_by?: string | null;
    created_at?: Date; // Optional - auto-generated by TypeORM @CreateDateColumn()
    updated_by?: string | null;
    updated_at?: Date; // Optional - auto-generated by TypeORM @UpdateDateColumn()
  }) {
    this.id = dto.id;
    this.desc1 = dto.desc1;
    this.deleted_by = dto.deleted_by ?? null;
    this.deleted_at = dto.deleted_at ?? null;
    this.created_by = dto.created_by ?? null;
    this.created_at = dto.created_at ?? getPHDateTime();
    this.updated_by = dto.updated_by ?? null;
    this.updated_at = dto.updated_at ?? getPHDateTime();
  }

  /** Static factory: create and validate. */
  static create(params: {
    desc1: string;
    created_by?: string | null;
  }): Barangay {
    const barangay = new Barangay({
      desc1: params.desc1,
      created_by: params.created_by ?? null,
    });
    barangay.validate();
    return barangay;
  }

  /** Update details; validate new state before applying. */
  update(dto: { desc1: string; updated_by?: string | null }): void {
    if (this.deleted_at) {
      throw new BarangayBusinessException(
        "Barangay is archived and cannot be updated",
        HTTP_STATUS.CONFLICT
      );
    }
    const tempBarangay = new Barangay({
      id: this.id,
      desc1: dto.desc1,
      created_at: this.created_at,
      updated_at: this.updated_at,
    });
    tempBarangay.validate();
    this.desc1 = dto.desc1;
    this.updated_by = dto.updated_by ?? null;
  }

  /** Soft-delete. */
  archive(deleted_by: string): void {
    if (this.deleted_at) {
      throw new BarangayBusinessException(
        "Barangay is already archived.",
        HTTP_STATUS.CONFLICT
      );
    }
    this.deleted_at = getPHDateTime();
    this.deleted_by = deleted_by;
  }

  /** Restore from archive. */
  restore(): void {
    if (!this.deleted_at) {
      throw new BarangayBusinessException(
        `Barangay with ID ${this.id} is not archived.`,
        HTTP_STATUS.CONFLICT
      );
    }
    this.deleted_at = null;
    this.deleted_by = null;
  }

  /** Enforce business rules. */
  validate(): void {
    if (!this.desc1 || this.desc1.trim().length === 0) {
      throw new BarangayBusinessException(
        "Barangay name is required and cannot be empty.",
        HTTP_STATUS.BAD_REQUEST
      );
    }
    if (this.desc1.length > 255) {
      throw new BarangayBusinessException(
        "Barangay name must not exceed 255 characters.",
        HTTP_STATUS.BAD_REQUEST
      );
    }
    if (this.desc1.trim().length < 3) {
      throw new BarangayBusinessException(
        "Barangay name must be at least 3 characters long.",
        HTTP_STATUS.BAD_REQUEST
      );
    }
  }
}
```

- **Properties:** id (optional), business fields, then audit fields in order: `deleted_by`, `deleted_at`, `created_by`, `created_at`, `updated_by`, `updated_at`.
- **Constructor:** Accept a DTO; use `?? null` for nullable audit fields; use `getPHDateTime()` (or equivalent) for `created_at` / `updated_at` when not provided.
- **create():** Static factory; build instance, call `validate()`, return.
- **update():** Reject if archived; validate via a temporary instance; then apply changes; do not set `updated_at` (ORM manages it).
- **archive():** Set `deleted_at` and `deleted_by`; throw if already archived.
- **restore():** Clear `deleted_at` and `deleted_by`; throw if not archived.
- **validate():** Throw `<Model>BusinessException` for rule violations (required, length, etc.).

## Constants: LOG ACTIONS (per model)

Define LOG ACTIONS for each model in `domain/constants/`, aligned with that model’s repository. Use as the default pattern (adjust keys to match repo methods):

```ts
export const BARANGAY_ACTIONS = {
  CREATE: "CREATE_BARANGAY",
  UPDATE: "UPDATE_BARANGAY",
  ARCHIVE: "ARCHIVE_BARANGAY",
  RESTORE: "RESTORE_BARANGAY",
  PAGINATED_LIST: "PAGINATED_LIST_BARANGAY",
  BY_DESCRIPTION: "BY_DESCRIPTION_BARANGAY",
  COMBOBOX: "COMBOBOX_BARANGAY",
} as const;
```

- Name: `<MODEL>_ACTIONS` (e.g. `BARANGAY_ACTIONS`, `USER_ACTIONS`). Values: `'<ACTION>_<MODEL>'`.
- Include one entry per repository operation you log (create, update, archive, restore, findPaginatedList, findByDescription, combobox, etc.). Add or remove actions per model.

## Domain exceptions (per model)

Define a business/domain exception for each model in `domain/exceptions/`. Extend `DomainException` from core and use `HTTP_STATUS` from shared constants. Use as the default pattern:

```ts
import { HTTP_STATUS } from "@shared/constants";
import { DomainException } from "@core/exceptions/domain.exception";

/**
 * Thrown when barangay data violates domain invariants or business rules
 */
export class BarangayBusinessException extends DomainException {
  constructor(message: string, status_code: number = HTTP_STATUS.BAD_REQUEST) {
    super(message, "BARANGAY_BUSINESS_EXCEPTION", status_code);
    this.name = "BarangayBusinessException";
  }
}
```

- Name: `<Model>BusinessException` (e.g. `BarangayBusinessException`, `UserBusinessException`). Code: `'<MODEL>_BUSINESS_EXCEPTION'`.
- One exception class per model; throw when domain invariants or business rules are violated. Domain may depend on `@core/exceptions` and `@shared/constants` for exceptions only.

## Standard audit fields (entities)

Every **entity** in `infrastructure/entities/` (per feature or in core) must include the following six audit fields in this **exact order**:

1. `deleted_by` – User who deleted the record
2. `deleted_at` – Timestamp when the record was soft-deleted
3. `created_by` – User who created the record
4. `created_at` – Timestamp when the record was created
5. `updated_by` – User who last updated the record
6. `updated_at` – Timestamp when the record was last updated

**Nullability**

- **Nullable** (can be `null`): `deleted_by`, `deleted_at`, `created_by`, `updated_by`
  - `deleted_by: string | null` – Only set when a record is soft-deleted
  - `deleted_at: Date | null` – Only set when a record is soft-deleted
  - `created_by: string | null` – May be unset for system-generated records, bulk operations, or migrations
  - `updated_by: string | null` – May be unset if the record has not been updated yet, or for system operations
- **Non-nullable** (cannot be `null`): `created_at`, `updated_at`
  - `created_at: Date` – Always set by the ORM (e.g. `@CreateDateColumn()`) when a record is created
  - `updated_at: Date` – Always set by the ORM (e.g. `@UpdateDateColumn()`) when a record is created or updated

**TypeORM decorators**

Use the following TypeORM decorators for audit fields (replace `[entity name]` with the entity name, e.g. barangay, user):

```ts
// User fields (nullable)
@Column({
  type: 'varchar',
  length: 255,
  comment: 'User who deleted the [entity name]',
  nullable: true,
})
deleted_by: string | null;

@Column({
  type: 'varchar',
  length: 255,
  comment: 'User who created the [entity name]',
  nullable: true,
})
created_by: string | null;

@Column({
  type: 'varchar',
  length: 255,
  comment: 'User who last updated the [entity name]',
  nullable: true,
})
updated_by: string | null;

// Timestamp fields
@DeleteDateColumn({ nullable: true })
@Index()
deleted_at: Date | null; // For soft delete

@CreateDateColumn()
created_at: Date;

@UpdateDateColumn()
updated_at: Date;
```

- Declare these fields in every persistence/ORM entity. Use the same names, order, nullability, and decorators so mappers and queries stay consistent across models.

## Rules

- One folder per feature; name folders in snake_case (e.g. `user_management`, `order_processing`).
- **Domain is independent.** The domain layer must have no dependencies on application, infrastructure, or external libraries. Domain contains only models, constants, exceptions, value objects, repository interfaces, and events. Domain may depend on `@core` (e.g. `DomainException`) and `@shared/constants` (e.g. `HTTP_STATUS`) for exceptions only.
- **Constants for each model live in `domain/constants/`.** Put model-specific constants (e.g. status codes, validation limits, default values) in the feature’s domain—one file per model (e.g. `barangay-constants.ts`) or grouped under constants. Shared constants used by more than one feature go in `core/domain/constants/`.
- **Dependencies live in infrastructure.** All framework, database, ORM, and external-service dependencies belong in the infrastructure layer. Domain models are mapped to infrastructure entities (e.g. ORM/DB entities) via mappers.
- **If it’s used in more than one feature, it belongs in `core/`.** Do not duplicate shared logic across features—extract to core and import from there.
- **Reusable utilities for all features live in `core/utils/`.** Put cross-feature helpers (formatting, validation, date/time, string helpers, etc.) in `core/utils/`. Feature-specific utilities stay in the feature; only shared ones go in core.
- **Shared decorators live in `core/infrastructure/decorators/`.** Put decorators used by more than one feature (validation, param extraction, etc.) in `core/infrastructure/decorators/`. Feature-specific decorators stay in the feature’s infrastructure or presentation layer.
- Keep feature folders self-contained. Only feature-specific code stays in a feature; reused code lives in `core/`.
- Prefer importing from the same feature. Cross-feature or shared use: import from `core/`.
- Each feature can expose a single module (e.g. `UserManagementModule`) that wires domain, application, and infrastructure for that feature.
- Do not create top-level folders like `controllers/`, `services/`, `repositories/` that mix all features.
